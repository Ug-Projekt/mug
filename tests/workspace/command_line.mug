import io;
import string;
import "stack.mug";
import memory;

func strlen(text: str): i64;

type CommandLine { command: str, args: [str], args_count: i32, echo_on: u1 }

type Result<T> { raw: T, err: u1 }

func Ok<T>(value: T): Result<T> {
	return new Result<T> { err: false, raw: value };
}

func No<T>(): Result<T> {
	return new Result<T> { err: true };
}

func (self: Result<T>) unwrap<T>(): T {
	if self.err { trap("unwrapped err", true); }

	return self.raw;
}

func (self: Result<T>) is_err<T>(): u1 {
	return self.err;
}

func trap(error: str, exit: u1) {
	println("Error: " + error);
	if exit { exit(1); }
}

func (self: CommandLine) echo() {
	if !self.echo_on { return; }
	var i: i32;
	
	while i < self.args_count {
		print(self.args[i]);
		print(' ');
		i++;
	}
	
	print('\n');
}

@[header("ls.cpp"), clang_args("-std=c++17")]
func c_ls(dir: str);

func (self: CommandLine) ls() {
	var dir = ".";

	if self.args_count > 0 { dir = self.args[0]; }
	
	c_ls(dir);
}

@[code("
#include <stdlib.h>

void $void_clear_screen_noargs() {
	#ifdef _WIN32
	system(\"cls\");
	#elif __linux__
	system(\"clear\");
	#endif
}
"), extern("$void_clear_screen_noargs")]
func clear();

@[header("readfile.cpp"), extern("$char_readfile_const_char")]
func c_read_file(path: str): str;

@[code("
int topointer(const char* s) {
	return (int)((void*)s);
}
")]
func topointer(string: str): i32;

func read_file(path: str): Result<str> {
	const result = c_read_file(path);

	if topointer(result) == 0 { return No<str>(); }

	return Ok<str>(result);
}

func (self: CommandLine) print() {
	var i: i32;

	while i < self.args_count {
		if i > 0 { println("\n\n"); }

		const filename = self.args[i];
		const text = read_file(filename);
		if text.is_err<str>() { println("Not a file"); }
		else { println(text.unwrap<str>()); }
		i++;
	}
}

func (this: *CommandLine) interpret_command() {
	const self = (*this);
	const command = self.command;

	if command == "cls" {
		clear();
	} elif command == "echo_off" {
		(*this).echo_on = false;
	} elif command == "echo_on" {
		(*this).echo_on = true;
	} elif command == "echo" {
		self.echo();
	} elif command == "ls" {
		self.ls();
	} elif command == "exit" {
		exit(0);
	} elif command == "print" {
		self.print();
	} else {
		trap("Invalid command `" + command + "`", false);
	}
}

func (self: str) split(char: chr): Stack<str> {
	const len = strlen(self) as i32;

	var i: i32;
	var result = Stack<str>(10);
	var builder: str;
	var builder_len: i32;

	while i < len {
		const cur = self[i];

		if cur == char {
			if builder_len > 0 {
				(&result).push<str>(builder);
				builder = "";
				builder_len = 0;
			}
		} else {
			builder += cur;
			builder_len++;
		}

		i++;
	}

	if builder_len > 0 { (&result).push<str>(builder); }

	return result;
}

func get_command_and_args(
	splitted: Stack<str>,
	command: *str,
	args: *[str],
	args_count: *i32) {

		*args_count = splitted.len - 1;
		*args = new [str, *args_count] { };
		var i: i32;

		while i < *args_count {
			(*args)[*args_count - i - 1] = (&splitted).pop<str>();
			i++;
		}

		*command = (&splitted).pop<str>();
}

func main() {
	var cmd = new CommandLine { echo_on: true };

	while true {
		var prompt: str;
		if cmd.echo_on { prompt = "$> "; }

		var splitted = readln(prompt).split(' ');

		if splitted.len == 0 { continue; }
		
		get_command_and_args(splitted, &(cmd.command), &(cmd.args), &(cmd.args_count));
	
		(&cmd).interpret_command();
	}
}